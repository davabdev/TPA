#pragma once
/*
* Truly Parallel Algorithms Library - Algorithm - generate function
* By: David Aaron Braun
* 2021-05-29
* Parallel implementation of generate
*/

/*
*           Copyright David Aaron Braun 2021 - .
*   Distributed under the Boost Software License, Version 1.0.
*       (See accompanying file LICENSE_1_0.txt or copy at
*           https://www.boost.org/LICENSE_1_0.txt)
*/

#include <type_traits>
#include <utility>
#include <iostream>
#include <future>
#include <atomic>
#include <random>
#include <array>
#include <vector>

#include "../tpa.hpp"
#include "../ThreadPool.hpp"
#include "../_util.hpp"
#include "../size_t_lit.hpp"
#include "../tpa_macros.hpp"
#include "../predicates.hpp"
#include "../tpa_concepts.hpp"
#include "../InstructionSet.hpp"
#include "../simd/simd.hpp"

/// <summary>
/// <para>Truly Parallel Algorithms</para>
/// <para>By David Aaron Braun</para>
/// <para>Version 0.1</para> 
/// </summary>
namespace tpa {

#pragma region generic

    /// <summary>
    /// <para>Fills the container with values generated from the specified predicate upto the item_count, if
    /// item_count is not specifed it will be set to the size of the container. </para>
    /// <para>All generated values are staticly cast to the value type of the container</para>
    /// <para>This parallel implementation utilizes multi-threading but not SIMD.</para>
    /// </summary>
    /// <typeparam name="CONTAINER"></typeparam>
    /// <typeparam name="GENERATOR"></typeparam>
    /// <param name="arr"></param>
    /// <param name="gen"></param>
    /// <param name="item_count"></param>
    template<typename CONTAINER, class GENERATOR>
    inline constexpr void generate(CONTAINER& arr, const GENERATOR gen, size_t item_count = 0)
    requires tpa::util::contiguous_seqeunce<CONTAINER>
    {
        try
        {
            //Prevent overflow
            if (item_count <= 0 || item_count > arr.size())
            {
                item_count = arr.size();
            }//End if

            uint32_t complete = 0;

            std::vector<std::pair<size_t, size_t>> sections;
            tpa::util::prepareThreading(sections, item_count);

            std::vector<std::shared_future<uint32_t>> results;
            results.reserve(tpa::nThreads);

            std::shared_future<uint32_t> temp;

            for (const auto& sec : sections)
            {
                temp = tpa::tp->addTask([&arr, &gen, &sec]()
                    {
                        const size_t beg = sec.first;
                        const size_t end = sec.second;
                        size_t i = beg;

                        const GENERATOR g = gen;
#pragma region generic      
                        for (; i != end; ++i)
                        {
                            arr[i] = static_cast<CONTAINER::value_type>(g());
                        }//End for
#pragma endregion

                        return 1u;
                    });//End of lambda

                results.emplace_back(std::move(temp));
            }//End for 

            for (const auto& fut : results)
            {
                complete += fut.get();
            }//End for

            //Check all threads completed
            if (complete != tpa::nThreads)
            {
                throw tpa::exceptions::NotAllThreadsCompleted(complete);
            }//End if

        }//End try
        catch (const std::future_error& ex)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): " << ex.code()
                << " " << ex.what() << "\n";
        }//End catch
        catch (const std::bad_alloc& ex)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): " << ex.what() << "\n";
        }//End catch
        catch (const std::exception& ex)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): " << ex.what() << "\n";
        }//End catch
        catch (...)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): unknown!\n";
        }//End catch
    }//End of generate

    /// <summary>
    /// <para>Fills the container with values generated by the specified predicate upto the item_count, if
    /// item_count is not specifed it will be set to the size of the container. </para>
    /// <para>All generated values are staticly cast to the value type of the container</para>
    /// <para>This parallel implementation utilizes multi-threading AND SIMD.</para>
    /// <para>Takes instructions:</para>
    /// <para>-------------------</para>
    /// <para>tpa::gen::EVEN</para>		
    /// <para>tpa::gen::ODD</para>	
    /// <para>tpa::gen::ALL_LESS_THAN</para>
    /// <para>tpa::gen::ALL_GREATER_THAN</para>
    /// </summary>
    /// <typeparam name="CONTAINER"></typeparam>
    /// <typeparam name="GENERATOR"></typeparam>
    /// <param name="arr"></param>
    /// <param name="param"> - Not used in all predicates. See predicate descriptions.</param>
    ///  <param name="param2"> - Not used in all predicates. See predicate descriptions.</param>
    /// <param name="item_count"></param>
    template<tpa::gen INSTR, typename CONTAINER, typename P = CONTAINER::value_type, typename P2 = CONTAINER::value_type>
    inline constexpr void generate(
        CONTAINER& arr, 
        const P param = 0, 
        const P2 param2 = 0, 
        size_t item_count = 0)
        requires tpa::util::contiguous_seqeunce<CONTAINER>
    {
        try
        {
            using T = CONTAINER::value_type;

            //Prevent overflow
            if (item_count <= 0 || item_count > arr.size())
            {
                item_count = arr.size();
            }//End if

            uint32_t complete = 0;

            std::vector<std::pair<size_t, size_t>> sections;
            tpa::util::prepareThreading(sections, item_count);

            std::vector<std::shared_future<uint32_t>> results;
            results.reserve(tpa::nThreads);

            std::shared_future<uint32_t> temp;

            for (const auto& sec : sections)
            {
                temp = tpa::tp->addTask([&arr, &param, &param2, &sec]()
                    {
                        const size_t beg = sec.first;
                        const size_t end = sec.second;
                        size_t i = beg;

                        const P arg1 = param;
                        const P2 arg2 = param2;
#pragma region byte
                    if constexpr (std::is_same<T, int8_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            int8_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int8_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<int8_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64,
                                    66, 68, 70, 72, 74, 78, 80, 82,
                                    84, 86, 88, 90, 92, 94, 96, 98,
                                    100,102,104,106,108,110,112,114,
                                    116,118,120,122,124,126,128);

                                __m512i _counter;

                                for (; i+64 < end; i += 64)
                                {
                                    _counter = _mm512_set1_epi8(static_cast<int8_t>((i * 2) + start));

                                    _counter = _mm512_add_epi8(_counter, _two);

                                    _mm512_storeu_epi8(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2) [[likely]]
                            {
                                const __m256i _two = _mm256_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64);
                                __m256i _counter;

                                for (; i+32 < end; i += 32)
                                {
                                    _counter = _mm256_set1_epi8(static_cast<int8_t>((i * 2) + start));

                                    _counter = _mm256_add_epi8(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif
                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            int8_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int8_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<int8_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64,
                                    66, 68, 70, 72, 74, 78, 80, 82,
                                    84, 86, 88, 90, 92, 94, 96, 98,
                                    100, 102, 104, 106, 108, 110, 112, 114,
                                    116, 118, 120, 122, 124, 126, 128);

                                __m512i _counter;

                                for (; i+64 < end; i += 64)
                                {
                                    _counter = _mm512_set1_epi8(static_cast<int8_t>((i * 2) + start));

                                    _counter = _mm512_add_epi8(_counter, _two);

                                    _mm512_storeu_epi8( &arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2) [[likely]]
                            {
                                const __m256i _two = _mm256_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64);
                                __m256i _counter;

                                for (; i+32 < end; i += 32)
                                {
                                    _counter = _mm256_set1_epi8(static_cast<int8_t>((i * 2) + start));

                                    _counter = _mm256_add_epi8(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif

                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _adder =
                                    _mm512_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
                           36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
                           56, 57, 58, 59, 60, 61, 62, 63);

                                __m512i _Val, _Res;

                                for (; i+64 < end; i += 64)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_epi8(static_cast<int8_t>(val));

                                    _Res = _mm512_add_epi8(_Val, _adder);

                                    _mm256_storeu_epi8(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2) [[likely]]
                            {
                                const __m256i _adder =
                                    _mm256_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);

                                __m256i _Val, _Res;

                                for (; i+32 < end; i += 32)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_epi8(static_cast<int8_t>(val));

                                    _Res = _mm256_add_epi8(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint16_t random = 0u;
                                for (; i != end; ++i)
                                {
                                    _rdrand16_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1u) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
                            uint8_t seed = static_cast<uint8_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 3u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 5u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::uniform_int_distribution<int16_t> distrib(
                                static_cast<int16_t>(arg1),
                                static_cast<int16_t>(arg2));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::binomial_distribution<int16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::negative_binomial_distribution<int16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::geometric_distribution<int16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSION_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::poisson_distribution<int16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::exponential_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::gamma_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::weibull_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::extreme_value_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::normal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::lognormal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::chi_squared_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::cauchy_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::fisher_f_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::student_t_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<int8_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region unsigned byte
                    else if constexpr (std::is_same<T, uint8_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            uint8_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<uint8_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<uint8_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64,
                                    66, 68, 70, 72, 74, 78, 80, 82,
                                    84, 86, 88, 90, 92, 94, 96, 98,
                                    100, 102, 104, 106, 108, 110, 112, 114,
                                    116, 118, 120, 122, 124, 126, 128);

                                __m512i _counter;

                                for (; i + 64 < end; i += 64)
                                {
                                    _counter = _mm512_set1_epi8(static_cast<uint8_t>((i * 2) + start));

                                    _counter = _mm512_add_epi8(_counter, _two);

                                    _mm512_storeu_epi8(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64);
                                __m256i _counter;

                                for (; i+32 < end; i += 32)
                                {
                                    _counter = _mm256_set1_epi8(static_cast<uint8_t>((i * 2) + start));

                                    _counter = _mm256_add_epi8(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif

                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            uint8_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(param))
                                {
                                    start = static_cast<uint8_t>((arg1 - 2));
                                }//End if
                                else
                                {
                                    start = static_cast<uint8_t>((arg1 - 1));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64,
                                    66, 68, 70, 72, 74, 78, 80, 82,
                                    84, 86, 88, 90, 92, 94, 96, 98,
                                    100, 102, 104, 106, 108, 110, 112, 114,
                                    116, 118, 120, 122, 124, 126, 128);

                                __m512i _counter;

                                for (; i + 64 < end; i += 64)
                                {
                                    _counter = _mm512_set1_epi8(static_cast<uint8_t>((i * 2) + start));

                                    _counter = _mm512_add_epi8(_counter, _two);

                                    _mm512_storeu_epi8(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi8(
                                    2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32,
                                    34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 62, 64);

                                __m256i _counter;

                                for (; i+32 < end; i += 32)
                                {
                                    _counter = _mm256_set1_epi8(static_cast<uint8_t>((i * 2) + start));

                                    _counter = _mm256_add_epi8(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif

                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _adder =
                                    _mm512_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
                           36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
                           56, 57, 58, 59, 60, 61, 62, 63);

                                __m512i _Val, _Res;

                                for (; i + 64 < end; i += 64)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_epi8(static_cast<int8_t>(val));

                                    _Res = _mm512_add_epi8(_Val, _adder);

                                    _mm256_storeu_epi8(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _adder =
                                    _mm256_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);

                                __m256i _Val, _Res;

                                for (; i+32 < end; i += 32)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_epi8(static_cast<uint8_t>(val));

                                    _Res = _mm256_add_epi8(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint16_t random = 0u;
                                for (; i != end; ++i)
                                {
                                    _rdrand16_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1u) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
                            uint8_t seed = static_cast<uint8_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 3u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 5u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::uniform_int_distribution<uint16_t> distrib(
                                static_cast<uint16_t>(arg1),
                                static_cast<uint16_t>(arg2));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::binomial_distribution<uint16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::negative_binomial_distribution<uint16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::geometric_distribution<uint16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::poisson_distribution<int16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::exponential_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::gamma_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::weibull_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::extreme_value_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::normal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::lognormal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::chi_squared_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::cauchy_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::fisher_f_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::student_t_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint8_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<uint8_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region short
                    else if constexpr (std::is_same<T, int16_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            int16_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int16_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<int16_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                   18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
                                   50, 52, 54, 56, 58, 60, 64);
                                __m512i _counter;

                                for (; i+32 < end; i += 32)
                                {
                                    _counter = _mm512_set1_epi16(static_cast<int16_t>((i * 2) + start));

                                    _counter = _mm512_add_epi16(_counter, _two);

                                    _mm256_storeu_epi16(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32);
                                __m256i _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm256_set1_epi16(static_cast<int16_t>((i * 2) + start));

                                    _counter = _mm256_add_epi16(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif
                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            int16_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int16_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<int16_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 64);
                                __m512i _counter;

                                for (; i+32 < end; i += 32)
                                {
                                    _counter = _mm512_set1_epi16(static_cast<int16_t>((i * 2) + start));

                                    _counter = _mm512_add_epi16(_counter, _two);

                                    _mm512_storeu_epi8(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32);
                                __m256i _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm256_set1_epi16(static_cast<int16_t>((i * 2) + start));

                                    _counter = _mm256_add_epi16(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif

                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _adder =
                                    _mm512_setr_epi16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);

                                __m256i _Val, _Res;

                                for (; i+32 < end; i += 32)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    if ((i + 16) > end) [[unlikely]]
                                    {
                                        break;
                                    }//End if

                                    _Val = _mm256_set1_epi16(static_cast<int16_t>(val));

                                    _Res = _mm256_add_epi16(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _adder =
                                    _mm256_setr_epi16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);

                                __m256i _Val, _Res;

                                for (; i+16 < end; i += 16)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_epi16(static_cast<int16_t>(val));

                                    _Res = _mm256_add_epi16(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint16_t random = 0u;
                                for (; i != end; ++i)
                                {
                                    _rdrand16_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1u) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                constexpr uint16_t thirteen = 13u;
                                constexpr uint16_t seven = 7u;
                                constexpr uint16_t seventeen = 17u;

                                const uint16_t range = ((arg2 + 1u) - arg1);

                                const __m512i _one = _mm512_set1_epi16(1u);
                                const __m512i _arg1 = _mm512_set1_epi16(static_cast<uint16_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi16(static_cast<uint16_t>(arg2));
                                const __m512i _range = _mm512_sub_epi16(_mm512_add_epi16(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();

                                __m512i _seed = _mm512_set_epi16(
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()));

                                for (; (i + 32uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi16(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi16(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi16(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    //_temp = tpa::util::_mm512_narrow_epi32(_seed, range);
                                    _temp = _mm512_rem_epu16(_seed, _range);
                                    _res = _mm512_add_epi16(_temp, _arg1);

                                    _mm512_storeu_epi16(&arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint16_t thirteen = 13u;
                                constexpr uint16_t seven = 7u;
                                constexpr uint16_t seventeen = 17u;

                                const uint16_t range = ((arg2 + 1u) - arg1);

                                const __m256i _one = _mm256_set1_epi16(1u);
                                const __m256i _arg1 = _mm256_set1_epi16(static_cast<uint16_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi16(static_cast<uint16_t>(arg2));
                                const __m256i _range = _mm256_sub_epi16(_mm256_add_epi16(_arg2, _one), _arg1);

                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();

                                __m256i _seed = _mm256_set_epi16(
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()));

                                for (; (i + 16uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi16(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi16(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi16(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range                                    
                                    _temp = _mm256_rem_epu16(_seed, _range);
                                    _res = _mm256_add_epi16(_temp, _arg1);                                    
                                    //_temp = tpa::util::_mm256_narrow_epi32(_seed, range);
                                    //_res = _mm256_add_epi32(_temp, _arg1);

                                    _mm256_store_si256((__m256i*) & arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint16_t thirteen = 13u;
                                constexpr uint16_t seven = 7u;
                                constexpr uint16_t seventeen = 17u;

                                const uint16_t range = ((arg2 + 1u) - arg1);

                                const __m128i _one = _mm_set1_epi16(1u);
                                const __m128i _arg1 = _mm_set1_epi16(static_cast<uint16_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi16(static_cast<uint16_t>(arg2));
                                const __m128i _range = _mm_sub_epi16(_mm_add_epi16(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();

                                __m128i _seed = _mm_set_epi16(
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()));

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi16(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi16(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi16(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    //Narrow Range                                    
                                    _temp = _mm_rem_epu16(_seed, _range);
                                    _res = _mm_add_epi16(_temp, _arg1);
                                    //_temp = tpa::util::_mm256_narrow_epi32(_seed, range);
                                    //_res = _mm256_add_epi32(_temp, _arg1);

                                    _mm_store_si128((__m128i*) & arr[i], _res);
                                }//End for
                            }//End if
#endif                            
                            uint16_t seed = static_cast<uint16_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 17u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::uniform_int_distribution<int16_t> distrib(
                                static_cast<int16_t>(arg1),
                                static_cast<int16_t>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::binomial_distribution<int16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::negative_binomial_distribution<int16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::geometric_distribution<int16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::poisson_distribution<int16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::exponential_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::gamma_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::weibull_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::extreme_value_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::normal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::lognormal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::chi_squared_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::cauchy_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::fisher_f_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::student_t_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<int16_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region unsigned short
                    else if constexpr (std::is_same<T, uint16_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            uint16_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<uint16_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<uint16_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 64);
                                __m512i _counter;

                                for (; i + 32 < end; i += 32)
                                {
                                    _counter = _mm512_set1_epi16(static_cast<int16_t>((i * 2) + start));

                                    _counter = _mm512_add_epi16(_counter, _two);

                                    _mm256_storeu_epi16(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32);
                                __m256i _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm256_set1_epi16(static_cast<uint16_t>((i * 2) + start));

                                    _counter = _mm256_add_epi16(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif

                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            uint16_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<uint16_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<uint16_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _two = _mm512_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
                                    50, 52, 54, 56, 58, 60, 64);
                                __m512i _counter;

                                for (; i + 32 < end; i += 32)
                                {
                                    _counter = _mm512_set1_epi16(static_cast<int16_t>((i * 2) + start));

                                    _counter = _mm512_add_epi16(_counter, _two);

                                    _mm512_storeu_epi8(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi16(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32);
                                __m256i _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm256_set1_epi16(static_cast<uint16_t>((i*2) + start));

                                    _counter = _mm256_add_epi16(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif
                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_ByteWord)
                            {
                                const __m512i _adder =
                                    _mm512_setr_epi16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);

                                __m256i _Val, _Res;

                                for (; i + 32 < end; i += 32)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    if ((i + 16) > end) [[unlikely]]
                                    {
                                        break;
                                    }//End if

                                    _Val = _mm256_set1_epi16(static_cast<int16_t>(val));

                                    _Res = _mm256_add_epi16(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _adder =
                                    _mm256_setr_epi16(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);

                                __m256i _Val, _Res;

                                for (; i+16 < end; i += 16)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_epi16(static_cast<uint16_t>(val));

                                    _Res = _mm256_add_epi16(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                        std::srand(std::time(NULL));

                        for (; i != end; ++i)
                        {
                            arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                        }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint16_t random = 0u;
                                for (; i != end; ++i)
                                {
                                    _rdrand16_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1u) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                        std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                constexpr uint16_t thirteen = 13u;
                                constexpr uint16_t seven = 7u;
                                constexpr uint16_t seventeen = 17u;

                                const uint16_t range = ((arg2 + 1u) - arg1);

                                const __m512i _one = _mm512_set1_epi16(1u);
                                const __m512i _arg1 = _mm512_set1_epi16(static_cast<uint16_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi16(static_cast<uint16_t>(arg2));
                                const __m512i _range = _mm512_sub_epi16(_mm512_add_epi16(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();

                                __m512i _seed = _mm512_set_epi16(
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()));

                                for (; (i + 32uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi16(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi16(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi16(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    //_temp = tpa::util::_mm512_narrow_epi32(_seed, range);
                                    _temp = _mm512_rem_epu16(_seed, _range);
                                    _res = _mm512_add_epi16(_temp, _arg1);

                                    _mm512_storeu_epi16(&arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint16_t thirteen = 13u;
                                constexpr uint16_t seven = 7u;
                                constexpr uint16_t seventeen = 17u;

                                const uint16_t range = ((arg2 + 1u) - arg1);

                                const __m256i _one = _mm256_set1_epi16(1u);
                                const __m256i _arg1 = _mm256_set1_epi16(static_cast<uint16_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi16(static_cast<uint16_t>(arg2));
                                const __m256i _range = _mm256_sub_epi16(_mm256_add_epi16(_arg2, _one), _arg1);

                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();

                                __m256i _seed = _mm256_set_epi16(
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()));

                                for (; (i + 16uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi16(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi16(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi16(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range                                    
                                    _temp = _mm256_rem_epu16(_seed, _range);
                                    _res = _mm256_add_epi16(_temp, _arg1);
                                    //_temp = tpa::util::_mm256_narrow_epi32(_seed, range);
                                    //_res = _mm256_add_epi32(_temp, _arg1);

                                    _mm256_store_si256((__m256i*) & arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint16_t thirteen = 13u;
                                constexpr uint16_t seven = 7u;
                                constexpr uint16_t seventeen = 17u;

                                const uint16_t range = ((arg2 + 1u) - arg1);

                                const __m128i _one = _mm_set1_epi16(1u);
                                const __m128i _arg1 = _mm_set1_epi16(static_cast<uint16_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi16(static_cast<uint16_t>(arg2));
                                const __m128i _range = _mm_sub_epi16(_mm_add_epi16(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();

                                __m128i _seed = _mm_set_epi16(
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()),
                                    static_cast<uint16_t>(e()));

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi16(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi16(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi16(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    //Narrow Range                                    
                                    _temp = _mm_rem_epu16(_seed, _range);
                                    _res = _mm_add_epi16(_temp, _arg1);
                                    //_temp = tpa::util::_mm256_narrow_epi32(_seed, range);
                                    //_res = _mm256_add_epi32(_temp, _arg1);

                                    _mm_store_si128((__m128i*) & arr[i], _res);
                                }//End for
                            }//End if
#endif                            
                            uint16_t seed = static_cast<uint16_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 17u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::uniform_int_distribution<uint16_t> distrib(
                                static_cast<uint16_t>(arg1),
                                static_cast<uint16_t>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::binomial_distribution<uint16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::negative_binomial_distribution<uint16_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::geometric_distribution<uint16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::poisson_distribution<uint16_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::exponential_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::gamma_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::weibull_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::extreme_value_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::normal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::lognormal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::chi_squared_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::cauchy_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::fisher_f_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::student_t_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint16_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<uint16_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region int
                    else if constexpr (std::is_same<T, int32_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            int32_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int32_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<int32_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _twos = _mm512_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16,
                                                                       18,20,22,24, 26, 28, 30, 32);
                                __m512i _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm512_set1_epi32(static_cast<int32_t>((i * 2) + start));

                                    _counter = _mm512_add_epi32(_counter, _twos);

                                    _mm512_store_epi32( &arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _twos = _mm256_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16);
                                __m256i _counter;                             

                                for (; i+8 < end; i += 8)
                                {
                                    _counter = _mm256_set1_epi32(static_cast<int32_t>((i * 2)+ start));

                                    _counter = _mm256_add_epi32(_counter, _twos);

                                    _mm256_store_si256((__m256i*) &arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif
                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            int32_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int32_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<int32_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _twos = _mm512_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32);
                                __m512i _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm512_set1_epi32(static_cast<int32_t>((i * 2) + start));

                                    _counter = _mm512_add_epi32(_counter, _twos);

                                    _mm512_store_epi32(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _twos = _mm256_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16);
                                __m256i _counter;

                                for (; i+8 < end; i += 8)
                                {
                                    _counter = _mm256_set1_epi32(static_cast<int32_t>((i * 2) + start));

                                    _counter = _mm256_add_epi32(_counter, _twos);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif
                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _adder = _mm512_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7,
                                                                         8, 9,10,11,12,13,14,15);

                                __m512i _Val, _Res;

                                for (; i+16 < end; i += 16)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_epi32(static_cast<int32_t>(val));

                                    _Res = _mm512_add_epi32(_Val, _adder);

                                    _mm512_store_epi32(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _adder = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);

                                __m256i _Val, _Res;

                                for (; i+8 < end; i += 8)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_epi32(static_cast<int32_t>(val));

                                    _Res = _mm256_add_epi32(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint32_t random = 0u;
                                for (; i != end; ++i)
                                {
                                    _rdrand32_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1u) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                        std::srand(std::time(NULL));

                        for (; i != end; ++i)
                        {
                            arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                        }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {   
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m512i _one = _mm512_set1_epi32(1u);
                                const __m512i _arg1 = _mm512_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m512i _range = _mm512_sub_epi32(_mm512_add_epi32(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();

                                __m512i _seed = _mm512_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 16uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi32(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi32(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi32(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);
                                                                        
                                    _temp = tpa::simd::_mm512_narrow_epi32(_seed, range);
                                    _res = _mm512_add_epi32(_temp, _arg1);

                                    _mm512_store_epi32(&arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;
                                
                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m256i _one = _mm256_set1_epi32(1u);
                                const __m256i _arg1 = _mm256_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi32(static_cast<uint32_t>(arg2));   
                                const __m256i _range = _mm256_sub_epi32(_mm256_add_epi32(_arg2, _one), _arg1);
                               
                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();
                                                                
                                __m256i _seed = _mm256_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));                              

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi32(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi32(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi32(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range
                                    /* SLOW!
                                    _temp = _mm256_rem_epu32(_seed, _range);
                                    _res = _mm256_add_epi32(_temp, _arg1);
                                    */
                                    _temp = tpa::simd::_mm256_narrow_epi32(_seed, range);
                                    _res = _mm256_add_epi32(_temp, _arg1);
                                    
                                    _mm256_store_si256((__m256i*) &arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m128i _one = _mm_set1_epi32(1u);
                                const __m128i _arg1 = _mm_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m128i _range = _mm_sub_epi32(_mm_add_epi32(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();

                                __m128i _seed = _mm_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 4uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi32(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi32(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi32(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);
                                                                        
                                    _temp = tpa::simd::_mm_narrow_epi32(_seed, range);
                                    _res = _mm_add_epi32(_temp, _arg1);

                                    _mm_store_si128((__m128i*) & arr[i], _res);
                                }//End for
                            }//End if
#endif                            
                            uint32_t seed = static_cast<uint32_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 17u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::uniform_int_distribution<int32_t> distrib(
                                static_cast<int32_t>(arg1),
                                static_cast<int32_t>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::binomial_distribution<int32_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::negative_binomial_distribution<int32_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                        //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::geometric_distribution<int32_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::poisson_distribution<int32_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::exponential_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::gamma_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::weibull_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::extreme_value_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::normal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::lognormal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::chi_squared_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::cauchy_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::fisher_f_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::student_t_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<int32_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region unsigned int
                    else if constexpr (std::is_same<T, uint32_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            uint32_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<uint32_t>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<uint32_t>((arg1 - 2));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _twos = _mm512_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32);
                                __m512i _counter;

                                for (; i + 16 < end; i += 16)
                                {
                                    _counter = _mm512_set1_epi32(static_cast<uint32_t>((i * 2) + start));

                                    _counter = _mm512_add_epi32(_counter, _twos);

                                    _mm512_store_epi32(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16);
                                __m256i _counter;

                                for (; i +8 < end; i += 8)
                                {
                                    _counter = _mm256_set1_epi32(static_cast<uint32_t>((i * 2) + start));

                                    _counter = _mm256_add_epi32(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX
#endif
                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            uint32_t start;

                            if (param == 0)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<uint32_t>((arg1 - 2));
                                }//End if
                                else
                                {
                                    start = static_cast<uint32_t>((arg1 - 1));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _twos = _mm512_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16,
                                    18, 20, 22, 24, 26, 28, 30, 32);
                                __m512i _counter;

                                for (; i + 16 < end; i += 16)
                                {
                                    _counter = _mm512_set1_epi32(static_cast<uint32_t>((i * 2) + start));

                                    _counter = _mm512_add_epi32(_counter, _twos);

                                    _mm512_store_epi32(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi32(2, 4, 6, 8, 10, 12, 14, 16);
                                __m256i _counter;

                                for (; i+8 < end; i += 8)
                                {
                                    _counter = _mm256_set1_epi32(static_cast<uint32_t>((i * 2) + start));

                                    _counter = _mm256_add_epi32(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX
#endif

                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _adder = _mm512_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7,
                                    8, 9, 10, 11, 12, 13, 14, 15);

                                __m512i _Val, _Res;

                                for (; i + 16 < end; i += 16)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_epi32(static_cast<uint32_t>(val));

                                    _Res = _mm512_add_epi32(_Val, _adder);

                                    _mm512_store_epi32(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _adder = _mm256_setr_epi32(0, 1, 2, 3, 4, 5, 6, 7);

                                __m256i _Val, _Res;

                                for (; i+8 < end; i += 8)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_epi32(static_cast<uint32_t>(val));

                                    _Res = _mm256_add_epi32(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint32_t random = 0u;
                                for (; i != end; ++i)
                                {
                                    _rdrand32_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1u) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m512i _one = _mm512_set1_epi32(1u);
                                const __m512i _arg1 = _mm512_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m512i _range = _mm512_sub_epi32(_mm512_add_epi32(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();

                                __m512i _seed = _mm512_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 16uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi32(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi32(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi32(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = tpa::simd::_mm512_narrow_epi32(_seed, range);
                                    _res = _mm512_add_epi32(_temp, _arg1);

                                    _mm512_store_epi32(&arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m256i _one = _mm256_set1_epi32(1u);
                                const __m256i _arg1 = _mm256_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m256i _range = _mm256_sub_epi32(_mm256_add_epi32(_arg2, _one), _arg1);

                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();

                                __m256i _seed = _mm256_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi32(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi32(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi32(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range
                                    /* SLOW!
                                    _temp = _mm256_rem_epu32(_seed, _range);
                                    _res = _mm256_add_epi32(_temp, _arg1);
                                    */
                                    _temp = tpa::simd::_mm256_narrow_epi32(_seed, range);
                                    _res = _mm256_add_epi32(_temp, _arg1);

                                    _mm256_store_si256((__m256i*) & arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m128i _one = _mm_set1_epi32(1u);
                                const __m128i _arg1 = _mm_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m128i _range = _mm_sub_epi32(_mm_add_epi32(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();

                                __m128i _seed = _mm_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 4uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi32(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi32(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi32(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = tpa::simd::_mm_narrow_epi32(_seed, range);
                                    _res = _mm_add_epi32(_temp, _arg1);

                                    _mm_store_si128((__m128i*) & arr[i], _res);
                                }//End for
                            }//End if
#endif                            
                            uint32_t seed = static_cast<uint32_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 17u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::uniform_int_distribution<uint32_t> distrib(
                                static_cast<uint32_t>(arg1),
                                static_cast<uint32_t>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::binomial_distribution<uint32_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::negative_binomial_distribution<uint32_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::geometric_distribution<uint32_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::poisson_distribution<uint32_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::exponential_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::gamma_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::weibull_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::extreme_value_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::normal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::lognormal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::chi_squared_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::cauchy_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::fisher_f_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::student_t_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint32_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<uint32_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region long
                    else if constexpr (std::is_same<T, int64_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            int64_t start;

                            if (arg1 == 0ll)//Starting number not specified
                            {
                                start = 0ll;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int64_t>((arg1 - 1ll));
                                }//End if
                                else
                                {
                                    start = static_cast<int64_t>((arg1 - 2ll));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _two = _mm512_setr_epi64(2, 4, 6, 8,
                                                                       10,12,14,16);
                                __m512i _counter;

                                for (; i+8 < end; i += 8)
                                {
                                    _counter = _mm512_set1_epi64(static_cast<int64_t>((i * 2) + start));

                                    _counter = _mm512_add_epi64(_counter, _two);

                                    _mm512_store_epi64(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi64x(2, 4, 6, 8);
                                __m256i _counter;

                                for (; i+4 < end; i += 4)
                                {
                                    _counter = _mm256_set1_epi64x(static_cast<int64_t>((i * 2) + start));

                                    _counter = _mm256_add_epi64(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif

                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            int64_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = -1ll;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<int64_t>((arg1 - 2ll));
                                }//End if
                                else
                                {
                                    start = static_cast<int64_t>((arg1 - 1ll));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _two = _mm512_setr_epi64(2, 4, 6, 8,
                                                                       10, 12, 14, 16);
                                __m512i _counter;

                                for (; i+8 < end; i += 8)
                                {
                                    _counter = _mm512_set1_epi64(static_cast<int64_t>((i * 2) + start));

                                    _counter = _mm512_add_epi64(_counter, _two);

                                    _mm512_store_epi64(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi64x(2, 4, 6, 8);
                                __m256i _counter;

                                for (; i+4 < end; i += 4)
                                {
                                    _counter = _mm256_set1_epi64x(static_cast<int64_t>((i * 2) + start));

                                    _counter = _mm256_add_epi64(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif
                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _adder = _mm512_setr_epi64(0, 1, 2, 3,
                                                                         4, 5, 6, 7);

                                __m512i _Val, _Res;

                                for (; i+8 < end; i += 8)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_epi64(static_cast<int64_t>(val));

                                    _Res = _mm512_add_epi64(_Val, _adder);

                                    _mm512_store_epi64(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _adder = _mm256_setr_epi64x(0, 1, 2, 3);

                                __m256i _Val, _Res;

                                for (; i+4 < end; i += 4)
                                {
                                    val = static_cast<T>(param + i);

                                    _Val = _mm256_set1_epi64x(static_cast<int64_t>(val));

                                    _Res = _mm256_add_epi64(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));
                            std::mt19937_64 gen(std::rand());

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (gen() % ((arg2 + 1u) - arg1)));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                        if (tpa::hasRD_RAND)
                        {
                            uint64_t random = 0ull;
                            for (; i != end; ++i)
                            {
                                _rdrand64_step(&random);
                                arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1ull) - arg1)));
                            }

                        }//End if
                        else
                        {
                            std::srand(std::time(NULL));
                            std::mt19937_64 gen(std::rand());

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (gen() % ((arg2 + 1ull) - arg1)));
                            }//End for
                        }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));
                            std::mt19937_64 gen(std::rand());

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (gen() % ((arg2 + 1ull) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_DWQW)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m512i _one = _mm512_set1_epi64(1ull);
                                const __m512i _arg1 = _mm512_set1_epi64(static_cast<uint64_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi64(static_cast<uint64_t>(arg2));
                                const __m512i _range = _mm512_sub_epi64(_mm512_add_epi64(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();

                                __m512i _seed = _mm512_set_epi64(
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()));

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi64(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi64(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi64(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = tpa::simd::_mm512_narrow_epi64(_seed, range);
                                    _res = _mm512_add_epi64(_temp, _arg1);

                                    _mm512_store_epi64(&arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m256i _one = _mm256_set1_epi64x(1ull);
                                const __m256i _arg1 = _mm256_set1_epi64x(static_cast<uint64_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi64x(static_cast<uint64_t>(arg2));
                                const __m256i _range = _mm256_sub_epi64(_mm256_add_epi64(_arg2, _one), _arg1);

                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();

                                __m256i _seed = _mm256_set_epi64x(
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()));

                                for (; (i + 4uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi64(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi64(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi64(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range
                                    /* SLOW!
                                    _temp = _mm256_rem_epu64(_seed, _range);
                                    _res = _mm256_add_epi64(_temp, _arg1);
                                    */
                                    _temp = tpa::simd::_mm256_narrow_epi64(_seed, range);
                                    _res = _mm256_add_epi64(_temp, _arg1);

                                    _mm256_store_si256((__m256i*) & arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m128i _one = _mm_set1_epi64x(1u);
                                const __m128i _arg1 = _mm_set1_epi64x(static_cast<uint64_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi64x(static_cast<uint64_t>(arg2));
                                const __m128i _range = _mm_sub_epi64(_mm_add_epi64(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();

                                __m128i _seed = _mm_set_epi64x(
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()));

                                for (; (i + 2uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi64(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi64(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi64(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = tpa::simd::_mm_narrow_epi64(_seed, range);
                                    _res = _mm_add_epi64(_temp, _arg1);

                                    _mm_store_si128((__m128i*) & arr[i], _res);
                                }//End for
                            }//End if
#endif                            
                            uint32_t seed = static_cast<uint32_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 17u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::uniform_int_distribution<int64_t> distrib(
                                static_cast<int64_t>(arg1),
                                static_cast<int64_t>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::binomial_distribution<int64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a NEGATIVE_BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::negative_binomial_distribution<int64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::geometric_distribution<int64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::poisson_distribution<int64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::exponential_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::gamma_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::weibull_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::extreme_value_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::normal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::lognormal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::chi_squared_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::cauchy_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::fisher_f_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::student_t_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<int64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<int64_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region unsigned long
                    else if constexpr (std::is_same<T, uint64_t>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            uint64_t start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0ull;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<uint64_t>((arg1 - 1ull));
                                }//End if
                                else
                                {
                                    start = static_cast<uint64_t>((arg1 - 2ull));
                                }//End if
                            }//End else

#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _two = _mm512_setr_epi64(2, 4, 6, 8,
                                    10, 12, 14, 16);
                                __m512i _counter;

                                for (; i + 8 < end; i += 8)
                                {
                                    _counter = _mm512_set1_epi64(static_cast<uint64_t>((i * 2) + start));

                                    _counter = _mm512_add_epi64(_counter, _two);

                                    _mm512_store_epi64(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi64x(2, 4, 6, 8);
                                __m256i _counter;

                                for (; i+4 < end; i += 4)
                                {
                                    _counter = _mm256_set1_epi64x(static_cast<uint64_t>((i * 2) + start));

                                    _counter = _mm256_add_epi64(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif

                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            uint64_t start;

                            if (arg1 == 0ull)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<uint64_t>((arg1 - 2ull));
                                }//End if
                                else
                                {
                                    start = static_cast<uint64_t>((arg1 - 1ull));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _two = _mm512_setr_epi64(2, 4, 6, 8,
                                    10, 12, 14, 16);
                                __m512i _counter;

                                for (; i + 8 < end; i += 8)
                                {
                                    _counter = _mm512_set1_epi64(static_cast<uint64_t>((i * 2) + start));

                                    _counter = _mm512_add_epi64(_counter, _two);

                                    _mm512_store_epi64(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _two = _mm256_setr_epi64x(2, 4, 6, 8);
                                __m256i _counter;

                                for (; i+4 < end; i += 4)
                                {
                                    _counter = _mm256_set1_epi64x(static_cast<uint64_t>((i * 2) + start));

                                    _counter = _mm256_add_epi64(_counter, _two);

                                    _mm256_store_si256((__m256i*) & arr[i], _counter);
                                }//End for
                            }//End if hasAVX2
#endif
                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512i _adder = _mm512_setr_epi64(0, 1, 2, 3,
                                    4, 5, 6, 7);

                                __m512i _Val, _Res;

                                for (; i + 8 < end; i += 8)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_epi64(static_cast<uint64_t>(val));

                                    _Res = _mm512_add_epi64(_Val, _adder);

                                    _mm512_store_epi64(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX2)
                            {
                                const __m256i _adder = _mm256_setr_epi64x(0, 1, 2, 3);

                                __m256i _Val, _Res;

                                for (; i+4 < end; i += 4)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_epi64x(static_cast<uint64_t>(val));

                                    _Res = _mm256_add_epi64(_Val, _adder);

                                    _mm256_store_si256((__m256i*) & arr[i], _Res);
                                }//End for
                            }//End if hasAVX2
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));
                            std::mt19937_64 gen(std::rand());

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (gen() % ((arg2 + 1u) - arg1)));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint64_t random = 0ull;
                                for (; i != end; ++i)
                                {
                                    _rdrand64_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1ull) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));
                                std::mt19937_64 gen(std::rand());

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (gen() % ((arg2 + 1ull) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));
                            std::mt19937_64 gen(std::rand());

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (gen() % ((arg2 + 1ull) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_DWQW)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m512i _one = _mm512_set1_epi64(1ull);
                                const __m512i _arg1 = _mm512_set1_epi64(static_cast<uint64_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi64(static_cast<uint64_t>(arg2));
                                const __m512i _range = _mm512_sub_epi64(_mm512_add_epi64(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();

                                __m512i _seed = _mm512_set_epi64(
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()));

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi64(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi64(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi64(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = tpa::simd::_mm512_narrow_epi64(_seed, range);
                                    _res = _mm512_add_epi64(_temp, _arg1);

                                    _mm512_store_epi64(&arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m256i _one = _mm256_set1_epi64x(1ull);
                                const __m256i _arg1 = _mm256_set1_epi64x(static_cast<uint64_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi64x(static_cast<uint64_t>(arg2));
                                const __m256i _range = _mm256_sub_epi64(_mm256_add_epi64(_arg2, _one), _arg1);

                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();

                                __m256i _seed = _mm256_set_epi64x(
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()));

                                for (; (i + 4uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi64(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi64(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi64(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range
                                    /* SLOW!
                                    _temp = _mm256_rem_epu64(_seed, _range);
                                    _res = _mm256_add_epi64(_temp, _arg1);
                                    */
                                    _temp = tpa::simd::_mm256_narrow_epi64(_seed, range);
                                    _res = _mm256_add_epi64(_temp, _arg1);

                                    _mm256_store_si256((__m256i*) & arr[i], _res);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m128i _one = _mm_set1_epi64x(1u);
                                const __m128i _arg1 = _mm_set1_epi64x(static_cast<uint64_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi64x(static_cast<uint64_t>(arg2));
                                const __m128i _range = _mm_sub_epi64(_mm_add_epi64(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();

                                __m128i _seed = _mm_set_epi64x(
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()));

                                for (; (i + 2uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi64(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi64(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi64(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = tpa::simd::_mm_narrow_epi64(_seed, range);
                                    _res = _mm_add_epi64(_temp, _arg1);

                                    _mm_store_si128((__m128i*) & arr[i], _res);
                                }//End for
                            }//End if
#endif                            
                            uint32_t seed = static_cast<uint32_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 17u);

                                arr[i] = static_cast<T>(arg1 + (seed % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_INT_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::uniform_int_distribution<uint64_t> distrib(
                                static_cast<uint64_t>(arg1),
                                static_cast<uint64_t>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::binomial_distribution<uint64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::negative_binomial_distribution<uint64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::geometric_distribution<uint64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::poisson_distribution<uint64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::exponential_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::gamma_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::weibull_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::extreme_value_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::normal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::lognormal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::chi_squared_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::cauchy_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::fisher_f_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::student_t_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<uint64_t>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<uint64_t>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region float
                    else if constexpr (std::is_same<T, float>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            float start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0.0f;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<float>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<float>((arg1 - 2));
                                }//End if
                            }//End else

#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512 _two = _mm512_setr_ps(2.0f, 4.0f, 6.0f, 8.0f, 10.0f, 12.0f, 14.0f, 16.0f, 18.0f, 20.0f, 22.0f, 24.0f, 24.0f, 26.0f, 28.0f, 30.0f, 32.0f);
                                __m512 _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm512_set1_ps(static_cast<float>(i * 2) + start);

                                    _counter = _mm512_add_ps(_counter, _two);

                                    _mm512_store_ps(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX)
                            {
                                const __m256 _two = _mm256_setr_ps(2.0f, 4.0f, 6.0f, 8.0f, 10.0f, 12.0f, 14.0f, 16.0f);
                                __m256 _counter;

                                for (; i+8 < end; i += 8)
                                {                                   
                                    _counter = _mm256_set1_ps(static_cast<float>(i * 2) + start);

                                    _counter = _mm256_add_ps(_counter, _two);

                                    _mm256_store_ps(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX
#endif

                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            float start;

                            if (arg1 == 0.0f)//Starting number not specified
                            {
                                start = -1.0f;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<float>((arg1 - 2));
                                }//End if
                                else
                                {
                                    start = static_cast<float>((arg1 - 1));
                                }//End if
                            }//End else
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512 _two = _mm512_setr_ps(2.0f, 4.0f, 6.0f, 8.0f, 10.0f, 12.0f, 14.0f, 16.0f, 18.0f, 20.0f, 22.0f, 24.0f, 24.0f, 26.0f, 28.0f, 30.0f, 32.0f);
                                __m512 _counter;

                                for (; i+16 < end; i += 16)
                                {
                                    _counter = _mm512_set1_ps(static_cast<float>((i * 2) + start));

                                    _counter = _mm512_add_ps(_counter, _two);

                                    _mm512_store_ps(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX
                            else if (tpa::hasAVX)
                            {
                                const __m256 _two = _mm256_setr_ps(2.0f, 4.0f, 6.0f, 8.0f, 10.0f, 12.0f, 14.0f, 16.0f);
                                __m256 _counter;

                                for (; i+8 < end; i += 8)
                                {
                                    _counter = _mm256_set1_ps(static_cast<float>((i * 2) + start));

                                    _counter = _mm256_add_ps(_counter, _two);

                                    _mm256_store_ps(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX
#endif
                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512 _adder = _mm512_setr_ps(0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f);

                                __m512 _Val, _Res;

                                for (; i+16 < end; i += 16)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_ps(static_cast<float>(val));

                                    _Res = _mm512_add_ps(_Val, _adder);

                                    _mm512_store_ps(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX)
                            {
                                const __m256 _adder = _mm256_setr_ps(0, 1, 2, 3, 4, 5, 6, 7);

                                __m256 _Val, _Res;

                                for (; i+8 < end; i += 8)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm256_set1_ps(static_cast<float>(val));

                                    _Res = _mm256_add_ps(_Val, _adder);

                                    _mm256_store_ps(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));
                            uint32_t random = 0u;
                            
                            for (; i != end; ++i)
                            {
                                random = std::rand();                                
                                arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1u) - arg1));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint32_t random = 0u;
                                
                                for (; i != end; ++i)
                                {
                                    _rdrand32_step(&random);                                    
                                    arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1u) - arg1));
                                }//End for

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));
                                uint32_t random = 0u;
                                
                                for (; i != end; ++i)
                                {
                                    random = std::rand();
                                    arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1u) - arg1));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));
                            uint32_t random = 0u;
                            
                            for (; i != end; ++i)
                            {
                                random = std::rand();
                                arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1u) - arg1));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m512i _one = _mm512_set1_epi32(1u);
                                const __m512i _arg1 = _mm512_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m512i _range = _mm512_sub_epi32(_mm512_add_epi32(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();
                                __m512 _fres = _mm512_setzero_ps();

                                __m512i _seed = _mm512_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 16uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi32(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi32(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi32(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = tpa::simd::_mm512_narrow_epi32(_seed, range);
                                    _res = _mm512_add_epi32(_temp, _arg1);

                                    _fres = _mm512_cvtepi32_ps(_res);

                                    _mm512_store_ps(&arr[i], _fres);
                                }//End for
                            }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m256i _one = _mm256_set1_epi32(1u);
                                const __m256i _arg1 = _mm256_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m256i _range = _mm256_sub_epi32(_mm256_add_epi32(_arg2, _one), _arg1);

                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();
                                __m256 _fres = _mm256_setzero_ps();

                                __m256i _seed = _mm256_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi32(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi32(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi32(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range
                                    /* SLOW!
                                    _temp = _mm256_rem_epu32(_seed, _range);
                                    _res = _mm256_add_epi32(_temp, _arg1);
                                    */
                                    _temp = tpa::simd::_mm256_narrow_epi32(_seed, range);
                                    _res = _mm256_add_epi32(_temp, _arg1);
                                    _fres = _mm256_cvtepi32_ps(_res);

                                    _mm256_store_ps(&arr[i], _fres);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint32_t thirteen = 13u;
                                constexpr uint32_t seven = 7u;
                                constexpr uint32_t seventeen = 17u;

                                const uint32_t range = ((arg2 + 1u) - arg1);

                                const __m128i _one = _mm_set1_epi32(1u);
                                const __m128i _arg1 = _mm_set1_epi32(static_cast<uint32_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi32(static_cast<uint32_t>(arg2));
                                const __m128i _range = _mm_sub_epi32(_mm_add_epi32(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();
                                __m128 _fres = _mm_setzero_ps();

                                __m128i _seed = _mm_set_epi32(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 4uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi32(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi32(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi32(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = tpa::simd::_mm_narrow_epi32(_seed, range);
                                    _res = _mm_add_epi32(_temp, _arg1);
                                    _fres = _mm_cvtepi32_ps(_res);

                                    _mm_store_ps(&arr[i], _fres);
                                }//End for
                            }//End if
#endif                            
                            uint32_t seed = static_cast<uint32_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13u);
                                seed ^= (seed >> 7u);
                                seed ^= (seed << 17u);

                                arr[i] = static_cast<T>(arg1 + (seed % (arg2 + 1u) - arg1));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_REAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::uniform_real_distribution<float> distrib(
                                static_cast<float>(arg1),
                                static_cast<float>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<float>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::binomial_distribution<int32_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<float>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::negative_binomial_distribution<int32_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<float>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::geometric_distribution<int32_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<float>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::poisson_distribution<int32_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<float>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::exponential_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::gamma_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::weibull_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::extreme_value_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::normal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::lognormal_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::chi_squared_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::cauchy_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::fisher_f_distribution<float> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937 gen(rd());
                            std::student_t_distribution<float> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<float>).");
                            }();
                        }//End else
                    }//End if
#pragma endregion
#pragma region double
                    else if constexpr (std::is_same<T, double>() == true)
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {         
                            double start;

                            if (arg1 == 0.0)//Starting number not specified
                            {
                                start = 0.0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<double>((arg1 - 1.0));
                                }//End if
                                else
                                {
                                    start = static_cast<double>((arg1 - 2.0));
                                }//End if
                            }//End else

#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512d _two = _mm512_setr_pd(2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0);
                                __m512d _counter;

                                for (; i + 8 < end; i += 8)
                                {
                                    _counter = _mm512_set1_pd(static_cast<double>(i * 2) + start);

                                    _counter = _mm512_add_pd(_counter, _two);

                                    _mm512_store_pd(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX512
                            else if (tpa::hasAVX)
                            {            
                                const __m256d _two = _mm256_setr_pd(2.0, 4.0, 6.0, 8.0);
                                __m256d _counter;                                

                                for (; i+4 < end; i += 4)
                                {
                                    _counter = _mm256_set1_pd(static_cast<double>(i * 2) + start);

                                    _counter = _mm256_add_pd(_counter, _two);

                                    _mm256_store_pd(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX
#endif

                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for
                                
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            double start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = -1.0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(param))
                                {
                                    start = static_cast<double>((arg1 - 2));
                                }//End if
                                else
                                {
                                    start = static_cast<double>((arg1 - 1));
                                }//End if
                            }//End else

#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512d _two = _mm512_setr_pd(2.0, 4.0, 6.0, 8.0,
                                                                   10.0,12.0,14.0,16.0);
                                __m512d _counter;

                                for (; i + 8 < end; i += 8)
                                {
                                    _counter = _mm512_set1_pd(static_cast<double>((i * 2) + start));

                                    _counter = _mm512_add_pd(_counter, _two);

                                    _mm512_store_pd(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX
                            else if (tpa::hasAVX)
                            {
                                const __m256d _two = _mm256_setr_pd(2.0, 4.0, 6.0, 8.0);
                                __m256d _counter;

                                for (; i+4 < end; i += 4)
                                {       
                                    _counter = _mm256_set1_pd(static_cast<double>((i * 2) + start));

                                    _counter = _mm256_add_pd(_counter, _two);

                                    _mm256_store_pd(&arr[i], _counter);
                                }//End for
                            }//End if hasAVX
#endif
                            T odd_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T val;
#ifdef TPA_X86_64
                            if (tpa::hasAVX512)
                            {
                                const __m512d _adder = _mm512_setr_pd(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0);

                                __m256d _Val, _Res;

                                for (; i+8 < end; i += 8)
                                {
                                    val = static_cast<T>(arg1 + i);

                                    _Val = _mm512_set1_pd(static_cast<double>(val));

                                    _Res = _mm512_add_pd(_Val, _adder);

                                    _mm512_store_pd(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX
                            else if (tpa::hasAVX)
                            {
                                const __m256d _adder = _mm256_setr_pd(0, 1, 2, 3);

                                __m256d _Val, _Res;

                                for (; i+4 < end; i += 4)
                                {                                    
                                    val = static_cast<T>(arg1 + i);
                                              
                                    _Val = _mm256_set1_pd(static_cast<double>(val));

                                    _Res = _mm256_add_pd(_Val, _adder);

                                    _mm256_store_pd(&arr[i], _Res);
                                }//End for
                            }//End if hasAVX
#endif
                            for (; i != end; ++i)
                            {
                                val = static_cast<T>(arg1 + i);
                                arr[i] = val;
                                ++val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));
                            std::mt19937_64 gen(std::rand());
                            uint64_t random = 0ull;

                            for (; i != end; ++i)
                            {
                                random = gen();
                                arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1ull) - arg1));
                            }//End for

                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                        if (tpa::hasRD_RAND)
                        {
                            uint64_t random = 0ull;

                            for (; i != end; ++i)
                            {
                                _rdrand64_step(&random);
                                arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1ull) - arg1));
                            }//End for

                        }//End if
                        else
                        {
                            std::srand(std::time(NULL));
                            std::mt19937_64 gen(std::rand());
                            uint32_t random = 0u;

                            for (; i != end; ++i)
                            {
                                random = gen();
                                arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1ull) - arg1));
                            }//End for
                        }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                        std::srand(std::time(NULL));
                        std::mt19937_64 gen(std::rand());
                        uint32_t random = 0u;

                        for (; i != end; ++i)
                        {
                            random = gen();
                            arr[i] = static_cast<T>(arg1 + (random % (arg2 + 1ull) - arg1));
                        }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
#ifdef TPA_X86_64
                            if (tpa::hasAVX512_DWQW)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m512i _one = _mm512_set1_epi64(1ull);
                                const __m512i _arg1 = _mm512_set1_epi64(static_cast<uint64_t>(arg1));
                                const __m512i _arg2 = _mm512_set1_epi64(static_cast<uint64_t>(arg2));
                                const __m512i _range = _mm512_sub_epi64(_mm512_add_epi64(_arg2, _one), _arg1);

                                __m512i _temp = _mm512_setzero_si512();
                                __m512i _res = _mm512_setzero_si512();
                                __m512d _fres = _mm512_setzero_pd();

                                __m512i _seed = _mm512_set_epi64(
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()),
                                    static_cast<uint64_t>(e()));

                                for (; (i + 8uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm512_slli_epi64(_seed, thirteen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_srli_epi64(_seed, seven);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = _mm512_slli_epi64(_seed, seventeen);
                                    _seed = _mm512_xor_si512(_seed, _temp);

                                    _temp = tpa::simd::_mm512_narrow_epi64(_seed, range);
                                    _res = _mm512_add_epi64(_temp, _arg1);

                                    _fres = _mm512_cvtepi64_pd(_res);

                                    _mm512_store_pd(&arr[i], _fres);
                                }//End for
                                }//End if
                            else if (tpa::hasAVX2 && tpa::hasFMA)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m256i _one = _mm256_set1_epi64x(1ull );
                                const __m256i _arg1 = _mm256_set1_epi64x(static_cast<uint64_t>(arg1));
                                const __m256i _arg2 = _mm256_set1_epi64x(static_cast<uint64_t>(arg2));
                                const __m256i _range = _mm256_sub_epi64(_mm256_add_epi64(_arg2, _one), _arg1);

                                __m256i _temp = _mm256_setzero_si256();
                                __m256i _res = _mm256_setzero_si256();
                                __m256d _fres = _mm256_setzero_pd();

                                __m256i _seed = _mm256_set_epi64x(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 4uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm256_slli_epi64(_seed, thirteen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_srli_epi64(_seed, seven);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    _temp = _mm256_slli_epi64(_seed, seventeen);
                                    _seed = _mm256_xor_si256(_seed, _temp);

                                    //Narrow Range
                                    /* SLOW!
                                    _temp = _mm256_rem_epu32(_seed, _range);
                                    _res = _mm256_add_epi32(_temp, _arg1);
                                    */
                                    _temp = tpa::simd::_mm256_narrow_epi64(_seed, range);
                                    _res = _mm256_add_epi64(_temp, _arg1);
                                    _fres = tpa::simd::_mm256_cvtepi64_pd(_res);

                                    _mm256_store_pd(&arr[i], _fres);
                                }//End for
                            }//End if
                            else if (tpa::has_SSE2)
                            {
                                constexpr uint64_t thirteen = 13ull;
                                constexpr uint64_t seven = 7ull;
                                constexpr uint64_t seventeen = 17ull;

                                const uint64_t range = ((arg2 + 1ull) - arg1);

                                const __m128i _one = _mm_set1_epi64x(1ull);
                                const __m128i _arg1 = _mm_set1_epi64x(static_cast<uint64_t>(arg1));
                                const __m128i _arg2 = _mm_set1_epi64x(static_cast<uint64_t>(arg2));
                                const __m128i _range = _mm_sub_epi64(_mm_add_epi64(_arg2, _one), _arg1);

                                __m128i _temp = _mm_setzero_si128();
                                __m128i _res = _mm_setzero_si128();
                                __m128d _fres = _mm_setzero_pd();

                                __m128i _seed = _mm_set_epi64x(
                                    static_cast<uint32_t>(e()),
                                    static_cast<uint32_t>(e()));

                                for (; (i + 2uz) < end; ++i)
                                {
                                    //Generate Random Numbers
                                    _temp = _mm_slli_epi64(_seed, thirteen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_srli_epi64(_seed, seven);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = _mm_slli_epi64(_seed, seventeen);
                                    _seed = _mm_xor_si128(_seed, _temp);

                                    _temp = tpa::simd::_mm_narrow_epi64(_seed, range);
                                    _res = _mm_add_epi64(_temp, _arg1);
                                    _fres = tpa::simd::_mm_cvtepi64_pd(_res);

                                    _mm_store_pd(&arr[i], _fres);
                                }//End for
                            }//End if
#endif                            
                            uint64_t seed = static_cast<uint64_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13ull);
                                seed ^= (seed >> 7ull);
                                seed ^= (seed << 17ull);

                                arr[i] = static_cast<T>(arg1 + (seed % (arg2 + 1ull) - arg1));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_REAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::uniform_real_distribution<double> distrib(
                                static_cast<double>(arg1),
                                static_cast<double>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<double>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::binomial_distribution<int64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<double>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::negative_binomial_distribution<int64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<double>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::geometric_distribution<int64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<double>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::poisson_distribution<int64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<double>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::exponential_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::gamma_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::weibull_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::extreme_value_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::normal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::lognormal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::chi_squared_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::cauchy_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::fisher_f_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::student_t_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = distrib(gen);
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                                {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<double>).");
                                }();
                            }//End else
                    }//End if
#pragma endregion
#pragma region generic      
                    else
                    {
                        //Generate
                        if constexpr (INSTR == tpa::gen::EVEN)
                        {
                            T start;

                            if (arg1 == 0)//Starting number not specified
                            {
                                start = 0;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<T>((arg1 - 1));
                                }//End if
                                else
                                {
                                    start = static_cast<T>((arg1 - 2));
                                }//End if
                            }//End else

                            T even_val = static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                even_val += 2;
                                arr[i] = even_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ODD)
                        {
                            T start;

                            if (param == 0)//Starting number not specified
                            {
                                start = -1;
                            }//End if
                            else
                            {
                                if (tpa::util::isOdd(arg1))
                                {
                                    start = static_cast<T>((arg1 - 2));
                                }//End if
                                else
                                {
                                    start = static_cast<T>((arg1 - 1));
                                }//End if
                            }//End else

                            T odd_val= static_cast<T>((i * 2) + start);

                            for (; i != end; ++i)
                            {
                                odd_val += 2;
                                arr[i] = odd_val;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_GREATER_THAN)
                        {
                            T paramVal = static_cast<T>(arg1 + i);

                            for (; i != end; ++i)
                            {
                                arr[i] = paramVal;
                                ++paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::ALL_LESS_THAN)
                        {
                            T paramVal;

                            for (; i != end; ++i)
                            {
                                paramVal = static_cast<T>((arg1 - i) - 1);

                                //Prevent Wrap-Around
                                if (paramVal > arg1) [[unlikely]]
                                {
                                    return static_cast<uint32_t>(1);
                                }//End if

                                arr[i] = paramVal;
                                --paramVal;
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STD_RAND)
                        {
                            std::srand(std::time(NULL));
                            std::mt19937_64 e(std::rand());

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (e() % ((arg2 + 1u) - arg1)));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::SECURE_RAND)
                        {
#ifdef TPA_X86_64
                            if (tpa::hasRD_RAND)
                            {
                                uint64_t random = 0u;
                                for (; i != end; ++i)
                                {
                                    _rdrand64_step(&random);
                                    arr[i] = static_cast<T>(arg1 + (random % ((arg2 + 1u) - arg1)));
                                }

                            }//End if
                            else
                            {
                                std::srand(std::time(NULL));
                                std::mt19937_64 e(std::rand());

                                for (; i != end; ++i)
                                {
                                    arr[i] = static_cast<T>(arg1 + (e() % ((arg2 + 1u) - arg1)));
                                }//End for
                            }//End else
#else
#pragma message("non-x86 architecture does not have secure random number generator hardware. Defaults to std::rand()")
                            std::srand(std::time(NULL));

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(arg1 + (std::rand() % ((arg2 + 1u) - arg1)));
                            }//End for
#endif
                        }//End if
                        else if constexpr (INSTR == tpa::gen::XOR_SHIFT)
                        {
                            std::srand(std::time(nullptr));
                            std::mt19937_64 e(std::rand());
                            int64_t seed = static_cast<int64_t>(e());

                            for (; i != end; ++i)
                            {
                                seed ^= (seed << 13ll);
                                seed ^= (seed >> 7ll);
                                seed ^= (seed << 17ll);
                                                                
                                arr[i] = static_cast<T>(arg1 + seed % ((arg2 + 1ll) - arg1));                                
                            }//End for                           
                        }//End if
                        else if constexpr (INSTR == tpa::gen::UNIFORM)
                        {
                            //Generate Random Numbers with a UNIFORM_REAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::uniform_real_distribution<double> distrib(
                                static_cast<double>(arg1),
                                static_cast<double>(arg2)
                            );

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BERNOULLI)
                        {
                            //Generate Random Numbers with a BERNOULLI_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::bernoulli_distribution distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::binomial_distribution<int64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NEGATIVE_BINOMIAL)
                        {
                            //Generate Random Numbers with a BINOMIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::negative_binomial_distribution<int64_t> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GEOMETRIC)
                        {
                            //Generate Random Numbers with a GEOMETRIC_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::geometric_distribution<int64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::POISSON)
                        {
                            //Generate Random Numbers with a POISSON_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::poisson_distribution<int64_t> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXPONENTIAL)
                        {
                            //Generate Random Numbers with a EXPONENTIAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::exponential_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::GAMMA)
                        {
                            //Generate Random Numbers with a GAMMA_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::gamma_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::WEIBULL)
                        {
                            //Generate Random Numbers with a WEIBULL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::weibull_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::EXTREME_VALUE)
                        {
                            //Generate Random Numbers with a EXTREME_VALUE__DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::extreme_value_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::NORMAL)
                        {
                            //Generate Random Numbers with a NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::normal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::LOG_NORMAL)
                        {
                            //Generate Random Numbers with a LOG_NORMAL_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::lognormal_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CHI_SQUARED)
                        {
                            //Generate Random Numbers with a CHI_SQUARED_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::chi_squared_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::CAUCHY)
                        {
                            //Generate Random Numbers with a CAUCHY_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::cauchy_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::FISHER_F)
                        {
                            //Generate Random Numbers with a FISHER_F_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::fisher_f_distribution<double> distrib(arg1, arg2);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else if constexpr (INSTR == tpa::gen::STUDENT_T)
                        {
                            //Generate Random Numbers with a STUDENT_T_DISTRIBTUION
                            std::random_device rd;
                            std::mt19937_64 gen(rd());
                            std::student_t_distribution<double> distrib(arg1);

                            for (; i != end; ++i)
                            {
                                arr[i] = static_cast<T>(distrib(gen));
                            }//End for
                        }//End if
                        else
                        {
                            [] <bool flag = false>()
                            {
                                static_assert(flag, " You have specifed an invalid predicate function in tpa::generate<__UNDEFINED_PREDICATE__>(CONTAINER<T>).");
                            }();
                        }//End else
                    }//End else
#pragma endregion

                        return static_cast<uint32_t>(1);
                    });//End of lambda

                results.emplace_back(std::move(temp));
            }//End for 

            for (const auto& fut : results)
            {
                complete += fut.get();
            }//End for

            //Check all threads completed
            if (complete != tpa::nThreads)
            {
                throw tpa::exceptions::NotAllThreadsCompleted(complete);
            }//End if

        }//End try
        catch (const std::future_error& ex)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): " << ex.code()
                << " " << ex.what() << "\n";
        }//End catch
        catch (const std::bad_alloc& ex)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): " << ex.what() << "\n";
        }//End catch
        catch (const std::exception& ex)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): " << ex.what() << "\n";
        }//End catch
        catch (...)
        {
            std::scoped_lock<std::mutex> lock(tpa::util::consoleMtx);
            std::cerr << "Exception thrown in tpa::generate<T>(): unknown!\n";
        }//End catch
    }//End of generate
#pragma endregion
}//End of namespace
